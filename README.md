# libparamset #
The libparamset is a software development kit for handling COmmand-Line (COL.) parameters and program tasks resolved from the predefined COL. paramer set.

The library supports:
* Long and short parameters.
* Concatenating of flags with length 1 (-ab instead of -a -b).
* Aliases for the names.
* Multiple values are supported for a single flag.
* Support for a simple configurations file.
* Parameter can be parsed from COL., read from configuration file or inserted from the code.
* Values can be filtered by, name (e.g. i), source (e.g. default), priority (e.g. 3) and index.
* Multiple sets can be merged.
* Collecting values that are not bound with any parameter (-i x y -c ...), where x is bound with -i but y is not).
* Support for parameter --, that will redirect every next tokens to a single parameter.
* Individual parse options for parameters (has value or not, can not be inserted from COL ...).
* Abstract format and content check functionality with autogenerated error messages.
* Abstract parameter transformation or repair functionality.
* Abstract object parsing functionality (e.g. extract double).
* Autogenerated typo suggestions (sensitivity can be modified).
* Unknown parameter autogenerated error messages.
* Abstract Wildcard expander (can be used to make -i * work on Windows).
* A task that specifies COL. parameters, which one are needed and which one are restricted, to run it properly.
* Support for task set, composed of multiple tasks, wherefrom a task can be extracted by specified parameter set.
* Autogenerated suggestions between multiple tasks for the user when it is impossible to resolve which task the user wants to perform.
* Autogenerated suggestions to fix the task user tries to perform.


## Installation ##

To build the libparamset, you need to have gcc and autotools. For building under Windows you need the Windows SDK.

To use libparamset in your C/C++ project, link it against the libparamset binary. 

If you do not want to build your own binaries, you can get the latest stable release from the Gaurdtime repository.
To set up the repository, save this repo file in your repositories directory (e.g. /etc/yum.repos.d/): 
[http://download.guardtime.com/ksi/configuration/guardtime.el6.repo](http://download.guardtime.com/ksi/configuration/guardtime.el6.repo)


## Usage ##


A simple example of a command-line tool that uses libparamset to specife parameter set and task set, read the command-line, handle errors and gives user some feedback to help get things working.
```C
#include <stdio.h>
#include <string.h>
#include <param_set/param_set.h>
#include <param_set/task_def.h>
#include <param_set/parameter.h>


enum {
	VALUE_OK = 0,
	VALUE_IS_NULL = 0x01,
	VALUE_IS_EMPTY = 0x02,
	VALUE_FILE_DOES_NOT_EXIST = 0x03,
};

int convertRepair_path(const char* arg, char* buf, unsigned len);
int isContentOk_path(const char* fname);
int isFormatOk_path(const char* fname);
const char *parameter_error_to_string(int err);

int main(int argc, char** argv, char **envp) {
	int res;
	PARAM_SET *set = NULL;
	TASK_SET *task_set = NULL;
	TASK *pTask = NULL;
	char buf[1024];

	
	/**
	 * Configure parameter set and its parameters.
	 * 1) Both o and i must not be NULL or empty string.
	 * 2) Both o and i converts '\' into '/'.
	 * 3) i must be a path to a file that must exist.
	 * 4) Next token after o and i is always bound with the flag.
	 * 5) All options with true or false do not bound anything.
	 */
	PARAM_SET_new("{i}{o}{dump}{debug}{r}{help|h}", &set);
	PARAM_SET_addControl(set, "o", isFormatOk_path, NULL, convertRepair_path, NULL);
	PARAM_SET_addControl(set, "i", isFormatOk_path, isContentOk_path, convertRepair_path, NULL);
	PARAM_SET_setParseOptions(set, "i,o", PST_PRSCMD_HAS_VALUE);
	PARAM_SET_setParseOptions(set, "dump,debug,h,r", PST_PRSCMD_HAS_NO_VALUE);


	/**
	 * Describe different tasks:
	 * util -h
	 * util -i file_in --dump [-o file_out]
	 * util -i file_in -o file_out -r
	 */
	TASK_SET_new(&task_set);
	TASK_SET_add(task_set, 0, "Help", "h", NULL, NULL, NULL);
	TASK_SET_add(task_set, 1, "Dump file", "i,dump", NULL, "h,r", NULL);
	TASK_SET_add(task_set, 2, "Reverse file", "i,r,o", NULL, "h,dump", NULL);

	/* Parse command-line. */
	PARAM_SET_parseCMD(set, argc, argv, NULL, 0);

	/* Check for typos and unknown parameters. */
	if (PARAM_SET_isTypoFailure(set)) {
			printf("%s\n", PARAM_SET_typosToString(set, PST_TOSTR_DOUBLE_HYPHEN, NULL, buf, sizeof(buf)));
			goto cleanup;
	} else if (PARAM_SET_isUnknown(set)){
			printf("%s\n", PARAM_SET_unknownsToString(set, "Error: ", buf, sizeof(buf)));
			goto cleanup;
	}

	/* Check for invalid values. */
	if (!PARAM_SET_isFormatOK(set)) {
		printf("%s\n", PARAM_SET_invalidParametersToString(set, NULL, parameter_error_to_string, buf, sizeof(buf)));
		goto cleanup;
	}

	/* As input parameter passed all checks try to extract a consistent task. */
	res = TASK_SET_analyzeConsistency(task_set, set, 0.2);
	res = TASK_SET_getConsistentTask(task_set, &pTask);

	/* If task is not extracted try to give user some suggestions what to do to make things work. */
	if (pTask == NULL) {
		int ID;
		if (TASK_SET_isOneFromSetTheTarget(task_set, 0.1, &ID)) {
			printf("%s", TASK_SET_howToRepair_toString(task_set, set, ID, NULL, buf, sizeof(buf)));
		} else {
			printf("%s", TASK_SET_suggestions_toString(task_set, 3, buf, sizeof(buf)));
		}

		goto cleanup;
	}

	/* Task is extracted, check which one to run. */
	switch(TASK_getID(pTask)) {
		case 0:
			printf("Print help.\n");
		break;

		case 1:
			printf("Dump File.\n");
		break;

		case 2:
			printf("Reverse File.\n");
		break;

		default:
			printf("Error.\n");
		break;
	}

cleanup:
	TASK_SET_free(task_set);
	PARAM_SET_free(set);
}

const char *parameter_error_to_string(int err) {
	switch(err) {
		case VALUE_OK: return "OK";
		case VALUE_IS_NULL: return "Parameter must have value";
		case VALUE_IS_EMPTY: return "Parameter must have content";
		case VALUE_FILE_DOES_NOT_EXIST: return "File does not exist";
		default: return "Unknown error";
	}
}

int isFormatOk_path(const char* fname) {
	if (fname == NULL) return VALUE_IS_NULL;
	else if (*fname == '\0');
	else return VALUE_OK;
}

int isContentOk_path(const char* fname) {
	int result = 1;
	FILE *f = NULL;
	f = fopen(fname, "r");
	result = f == NULL ? VALUE_FILE_DOES_NOT_EXIST : 0;
	if (f != NULL) fclose(f);
	return result;
}

int convertRepair_path(const char* arg, char* buf, unsigned len){
	char *toBeReplaced = NULL;

	if (arg == NULL || buf == NULL) return 0;
	strncpy(buf, arg, len - 1);


	toBeReplaced = buf;
	while ((toBeReplaced = strchr(toBeReplaced, '\\')) != NULL){
		*toBeReplaced = '/';
		toBeReplaced++;
	}

	return 1;
}

```
## License ##

See LICENSE file.


## Dependencies ##
| Dependency        | Version                           | License type | Source                         | Notes |
| :---              | :---                              | :---         | :---                           |:---   |
| CuTest            | 1.5                               | Zlib         |                                | Required only for testing. |


## Compatibility ##
| OS / Platform                              | Compatibility                                |
| :---                                       | :---                                         | 
| CentOS / RHEL 6 and 7, x86_64 architecture | Fully compatible and tested.                  |
| Windows 7, 8, 10                           | Compatible but not tested on a regular basis. Build combination of DLL=dll and RTL=MT(d) not supported. |
